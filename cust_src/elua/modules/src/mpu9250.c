// MPU9250 Driver.
// Reference: https://github.com/AnswerInTheWind/Peripheral
// Thanks to @AnswerInTheWind

#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include "auxmods.h"
#include "lrotable.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <malloc.h>

#include "platform.h"
#include "platform_conf.h"
#include "platform_i2c.h"
#include "platform_rtos.h"
#include "platform_malloc.h"
#include "mpu9250.h"

typedef union
{
  double value;
  struct
  {
    u32 lsw;
    u32 msw;
  } parts;
} ieee_double_shape_type;

//#endif

/* Get two 32 bit ints from a double.  */

#define EXTRACT_WORDS(ix0,ix1,d)				\
do {								\
  ieee_double_shape_type ew_u;					\
  ew_u.value = (d);						\
  (ix0) = ew_u.parts.msw;					\
  (ix1) = ew_u.parts.lsw;					\
} while (0)

/* Get the more significant 32 bit int from a double.  */

#define GET_HIGH_WORD(i,d)					\
do {								\
  ieee_double_shape_type gh_u;					\
  gh_u.value = (d);						\
  (i) = gh_u.parts.msw;						\
} while (0)

/* Get the less significant 32 bit int from a double.  */

#define GET_LOW_WORD(i,d)					\
do {								\
  ieee_double_shape_type gl_u;					\
  gl_u.value = (d);						\
  (i) = gl_u.parts.lsw;						\
} while (0)

/* Set a double from two 32 bit ints.  */

#define INSERT_WORDS(d,ix0,ix1)					\
do {								\
  ieee_double_shape_type iw_u;					\
  iw_u.parts.msw = (ix0);					\
  iw_u.parts.lsw = (ix1);					\
  (d) = iw_u.value;						\
} while (0)

/* Set the more significant 32 bits of a double from an int.  */

#define SET_HIGH_WORD(d,v)					\
do {								\
  ieee_double_shape_type sh_u;					\
  sh_u.value = (d);						\
  sh_u.parts.msw = (v);						\
  (d) = sh_u.value;						\
} while (0)

/* Set the less significant 32 bits of a double from an int.  */

#define SET_LOW_WORD(d,v)					\
do {								\
  ieee_double_shape_type sl_u;					\
  sl_u.value = (d);						\
  sl_u.parts.lsw = (v);						\
  (d) = sl_u.value;						\
} while (0)

/* A union which permits us to convert between a float and a 32 bit
   int.  */

typedef union
{
  float value;
  u32 word;
} ieee_float_shape_type;

/* Get a 32 bit int from a float.  */

#define GET_FLOAT_WORD(i,d)					\
do {								\
  ieee_float_shape_type gf_u;					\
  gf_u.value = (d);						\
  (i) = gf_u.word;						\
} while (0)

/* Set a float from a 32 bit int.  */

#define SET_FLOAT_WORD(d,i)					\
do {								\
  ieee_float_shape_type sf_u;					\
  sf_u.word = (i);						\
  (d) = sf_u.value;						\
} while (0)



double lsqrt (double);
double lasin (double);
double latan2 (double,double);
double latan (double);
double lfabs(double);



static u8 mpu9250_i2c_id = 2;	// default


const unsigned char dmpmemorydata[1929]={
 // bank 0, 256 bytes
    0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
    0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
    0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
    0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,

    // bank 1, 256 bytes
    0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
    0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
    0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
    0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,

    // bank 2, 256 bytes
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // bank 3, 256 bytes
    0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
    0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
    0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
    0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
    0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
    0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
    0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
    0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
    0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
    0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
    0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
    0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
    0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
    0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
    0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
    0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,

    // bank 4, 256 bytes
    0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
    0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
    0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
    0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
    0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
    0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
    0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
    0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
    0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
    0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
    0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
    0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
    0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
    0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,

    // bank 5, 256 bytes
    0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
    0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
    0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
    0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
    0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
    0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
    0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
    0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
    0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
    0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
    0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
    0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
    0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
    0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
    0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
    0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,

    // bank 6, 256 bytes
    0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
    0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
    0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
    0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
    0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
    0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
    0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
    0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
    0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
    0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
    0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
    0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
    0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
    0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
    0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
    0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,

    // bank 7, 138 bytes (remainder)
    0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
    0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
    0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
    0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
    0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
    0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
    0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
    0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
    0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

const unsigned char dmpcfgupddata[239] = {
//  dmp config 
//  BANK    OFFSET  LENGTH  [DATA]
    0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         
    0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         
    0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   
    0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   
    0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, 
    0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         
    0x00,   0x6C,   0x02,   0x20, 0x00,               
    0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,  
    0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   
    0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,  
    0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
    0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         
    0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   
    0x00,   0xA3,   0x01,   0x00,                    
    0x00,   0x00,   0x01,   0x01, 
    //?????????
    //0x00,   0x00,   0x00,   0x01,  ?LENGTH=0x00,??
        
    0x07,   0x86,   0x01,   0xFE,                     
    0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, 
    0x07,   0x7E,   0x01,   0x30,                   
    0x07,   0x46,   0x01,   0x9A,                    
    0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   
    0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,  
    0x02,   0x16,   0x02,   0x00, 0x00,              
// FIFO rate :0x00=200HZ,0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ, 

//dmp updates
    0x01,   0xB2,   0x02,   0xFF, 0xFF,
    0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
    0x01,   0x6A,   0x02,   0x06, 0x00,
    0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
    0x01,   0x62,   0x02,   0x00, 0x00,
    0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
};



// Math functions

static const double 
tiny = 1.0e-300;
static const double
zero  = 0.0,
pi_o_4  = 7.8539816339744827900E-01, /* 0x3FE921FB, 0x54442D18 */
pi_o_2  = 1.5707963267948965580E+00, /* 0x3FF921FB, 0x54442D18 */
pi      = 3.1415926535897931160E+00, /* 0x400921FB, 0x54442D18 */
pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */

static const  double
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
huge =  1.000e+300,
pio2_hi =  1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
pio2_lo =  6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
pio4_hi =  7.85398163397448278999e-01, /* 0x3FE921FB, 0x54442D18 */
/* coefficient for R(x^2) */
pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */

static const
double atanhi[] = {
	4.63647609000806093515e-01, /* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
	7.85398163397448278999e-01, /* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
	9.82793723247329054082e-01, /* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
	1.57079632679489655800e+00, /* atan(inf)hi 0x3FF921FB, 0x54442D18 */
};

static const
double atanlo[] = {
	2.26987774529616870924e-17, /* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
	3.06161699786838301793e-17, /* atan(1.0)lo 0x3C81A626, 0x33145C07 */
	1.39033110312309984516e-17, /* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
	6.12323399573676603587e-17, /* atan(inf)lo 0x3C91A626, 0x33145C07 */
};

static const
double aT[] = {
	3.33333333333329318027e-01, /* 0x3FD55555, 0x5555550D */
	-1.99999999998764832476e-01, /* 0xBFC99999, 0x9998EBC4 */
	1.42857142725034663711e-01, /* 0x3FC24924, 0x920083FF */
	-1.11111104054623557880e-01, /* 0xBFBC71C6, 0xFE231671 */
	9.09088713343650656196e-02, /* 0x3FB745CD, 0xC54C206E */
	-7.69187620504482999495e-02, /* 0xBFB3B0F2, 0xAF749A6D */
	6.66107313738753120669e-02, /* 0x3FB10D66, 0xA0D03D51 */
	-5.83357013379057348645e-02, /* 0xBFADDE2D, 0x52DEFD9A */
	4.97687799461593236017e-02, /* 0x3FA97B4B, 0x24760DEB */
	-3.65315727442169155270e-02, /* 0xBFA2B444, 0x2C6A6C2F */
	1.62858201153657823623e-02, /* 0x3F90AD3A, 0xE322DA11 */
};

double lfabs(double x)
{
	u32 high;
	GET_HIGH_WORD(high,x);
	SET_HIGH_WORD(x,high&0x7fffffff);
        return x;
}

double lasin(double x)
{
  

	double t=0.0,w,p,q,c,r,s;
	s32 hx,ix;
	GET_HIGH_WORD(hx,x);
	ix = hx&0x7fffffff;
	if(ix>= 0x3ff00000) {		/* |x|>= 1 */
	    u32 lx;
	    GET_LOW_WORD(lx,x);
	    if(((ix-0x3ff00000)|lx)==0)
		    /* asin(1)=+-pi/2 with inexact */
		return x*pio2_hi+x*pio2_lo;
	    return (x-x)/(x-x);		/* asin(|x|>1) is NaN */
	} else if (ix<0x3fe00000) {	/* |x|<0.5 */
	    if(ix<0x3e400000) {		/* if |x| < 2**-27 */
		if(huge+x>one) return x;/* return x with inexact if x!=0*/
	    } else {
		t = x*x;
		p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
		q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
		w = p/q;
		return x+x*w;
	    }
	}
	/* 1> |x|>= 0.5 */
	w = one-lfabs(x);
	t = w*0.5;
	p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
	q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
	s = lsqrt(t);
	if(ix>=0x3FEF3333) { 	/* if |x| > 0.975 */
	    w = p/q;
	    t = pio2_hi-(2.0*(s+s*w)-pio2_lo);
	} else {
	    w  = s;
	    SET_LOW_WORD(w,0);
	    c  = (t-w*w)/(s+w);
	    r  = p/q;
	    p  = 2.0*s*r-(pio2_lo-2.0*c);
	    q  = pio4_hi-2.0*w;
	    t  = pio4_hi-(p-q);
	}
	if(hx>0) return t; else return -t;
}

double latan(double x)
{

	double w,s1,s2,z;
	s32 ix,hx,id;

	GET_HIGH_WORD(hx,x);
	ix = hx&0x7fffffff;
	if(ix>=0x44100000) {	/* if |x| >= 2^66 */
	    u32 low;
	    GET_LOW_WORD(low,x);
	    if(ix>0x7ff00000||
		(ix==0x7ff00000&&(low!=0)))
		return x+x;		/* NaN */
	    if(hx>0) return  atanhi[3]+atanlo[3];
	    else     return -atanhi[3]-atanlo[3];
	} if (ix < 0x3fdc0000) {	/* |x| < 0.4375 */
	    if (ix < 0x3e200000) {	/* |x| < 2^-29 */
		if(huge+x>one) return x;	/* raise inexact */
	    }
	    id = -1;
	} else {
	x = lfabs(x);
	if (ix < 0x3ff30000) {		/* |x| < 1.1875 */
	    if (ix < 0x3fe60000) {	/* 7/16 <=|x|<11/16 */
		id = 0; x = (2.0*x-one)/(2.0+x);
	    } else {			/* 11/16<=|x|< 19/16 */
		id = 1; x  = (x-one)/(x+one);
	    }
	} else {
	    if (ix < 0x40038000) {	/* |x| < 2.4375 */
		id = 2; x  = (x-1.5)/(one+1.5*x);
	    } else {			/* 2.4375 <= |x| < 2^66 */
		id = 3; x  = -1.0/x;
	    }
	}}
    /* end of argument reduction */
	z = x*x;
	w = z*z;
    /* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
	s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));
	s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));
	if (id<0) return x - x*(s1+s2);
	else {
	    z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
	    return (hx<0)? -z:z;
	}
}

double latan2(double y, double x)
{
  

	double z;
	s32 k,m,hx,hy,ix,iy;
	u32 lx,ly;

	EXTRACT_WORDS(hx,lx,x);
	ix = hx&0x7fffffff;
	EXTRACT_WORDS(hy,ly,y);
	iy = hy&0x7fffffff;
	if(((ix|((lx|-lx)>>31))>0x7ff00000)||
	   ((iy|((ly|-ly)>>31))>0x7ff00000))	/* x or y is NaN */
	   return x+y;
	if(((hx-0x3ff00000)|lx)==0) return latan(y);   /* x=1.0 */
	m = ((hy>>31)&1)|((hx>>30)&2);	/* 2*sign(x)+sign(y) */

    /* when y = 0 */
	if((iy|ly)==0) {
	    switch(m) {
		case 0:
		case 1: return y; 	/* atan(+-0,+anything)=+-0 */
		case 2: return  pi+tiny;/* atan(+0,-anything) = pi */
		case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */
	    }
	}
    /* when x = 0 */
	if((ix|lx)==0) return (hy<0)?  -pi_o_2-tiny: pi_o_2+tiny;

    /* when x is INF */
	if(ix==0x7ff00000) {
	    if(iy==0x7ff00000) {
		switch(m) {
		    case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */
		    case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */
		    case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/
		    case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/
		}
	    } else {
		switch(m) {
		    case 0: return  zero  ;	/* atan(+...,+INF) */
		    case 1: return -zero  ;	/* atan(-...,+INF) */
		    case 2: return  pi+tiny  ;	/* atan(+...,-INF) */
		    case 3: return -pi-tiny  ;	/* atan(-...,-INF) */
		}
	    }
	}
    /* when y is INF */
	if(iy==0x7ff00000) return (hy<0)? -pi_o_2-tiny: pi_o_2+tiny;

    /* compute y/x */
	k = (iy-ix)>>20;
	if(k > 60) z=pi_o_2+0.5*pi_lo; 	/* |y/x| >  2**60 */
	else if(hx<0&&k<-60) z=0.0; 	/* |y|/x < -2**60 */
	else z=latan(lfabs(y/x));		/* safe to do y/x */
	switch (m) {
	    case 0: return       z  ;	/* atan(+,+) */
	    case 1: {
	    	      u32 zh;
		      GET_HIGH_WORD(zh,z);
		      SET_HIGH_WORD(z,zh ^ 0x80000000);
		    }
		    return       z  ;	/* atan(-,+) */
	    case 2: return  pi-(z-pi_lo);/* atan(+,-) */
	    default: /* case 3 */
	    	    return  (z-pi_lo)-pi;/* atan(-,-) */
	}
}

double lsqrt(double x)
{
  
	double z;
	s32 sign = (s32)0x80000000;
	s32 ix0,s0,q,m,t,i;
	u32 r,t1,s1,ix1,q1;

	EXTRACT_WORDS(ix0,ix1,x);

    /* take care of Inf and NaN */
	if((ix0&0x7ff00000)==0x7ff00000) {
	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
					   sqrt(-inf)=sNaN */
	}
    /* take care of zero */
	if(ix0<=0) {
	    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
	    else if(ix0<0)
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
	}
    /* normalize x */
	m = (ix0>>20);
	if(m==0) {				/* subnormal x */
	    while(ix0==0) {
		m -= 21;
		ix0 |= (ix1>>11); ix1 <<= 21;
	    }
	    for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;
	    m -= i-1;
	    ix0 |= (ix1>>(32-i));
	    ix1 <<= i;
	}
	m -= 1023;	/* unbias exponent */
	ix0 = (ix0&0x000fffff)|0x00100000;
	if(m&1){	/* odd m, double x to make it even */
	    ix0 += ix0 + ((ix1&sign)>>31);
	    ix1 += ix1;
	}
	m >>= 1;	/* m = [m/2] */

    /* generate sqrt(x) bit by bit */
	ix0 += ix0 + ((ix1&sign)>>31);
	ix1 += ix1;
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
	r = 0x00200000;		/* r = moving bit from right to left */

	while(r!=0) {
	    t = s0+r;
	    if(t<=ix0) {
		s0   = t+r;
		ix0 -= t;
		q   += r;
	    }
	    ix0 += ix0 + ((ix1&sign)>>31);
	    ix1 += ix1;
	    r>>=1;
	}

	r = sign;
	while(r!=0) {
	    t1 = s1+r;
	    t  = s0;
	    if((t<ix0)||((t==ix0)&&(t1<=ix1))) {
		s1  = t1+r;
		if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;
		ix0 -= t;
		if (ix1 < t1) ix0 -= 1;
		ix1 -= t1;
		q1  += r;
	    }
	    ix0 += ix0 + ((ix1&sign)>>31);
	    ix1 += ix1;
	    r>>=1;
	}

    /* use floating add to find out rounding direction */
	if((ix0|ix1)!=0) {
	    z = one-tiny; /* trigger inexact flag */
	    if (z>=one) {
	        z = one+tiny;
	        if (q1==(u32)0xffffffff) { q1=0; q += 1;}
		else if (z>one) {
		    if (q1==(u32)0xfffffffe) q+=1;
		    q1+=2;
		} else
	            q1 += (q1&1);
	    }
	}
	ix0 = (q>>1)+0x3fe00000;
	ix1 =  q1>>1;
	if ((q&1)==1) ix1 |= sign;
	ix0 += (m <<20);
	INSERT_WORDS(z,ix0,ix1);
	return z;
}



// glue layer
void Delayms(u32 m)
{
	platform_os_sleep(m);
}

void IICwriteByte(u8 dev_addr, u8 reg_addr, u8 dat)
{
	u16 slave_addr = I2C_NULL_SLAVE_ADDR;
	u8 buf[1];
	buf[0] = dat;
	platform_i2c_send_data(mpu9250_i2c_id, slave_addr, &reg_addr, buf, 1);
}

void IICreadBytes(u8 dev_addr, u8 reg_addr, int len, u8 * dat) 
{
	u16 slave_addr = I2C_NULL_SLAVE_ADDR;
	platform_i2c_recv_data(mpu9250_i2c_id, slave_addr, &reg_addr, dat, len);
	return;
}

u8 IIC_ReadOneByte(u8 dev_addr, u8 reg_addr)
{
	u8 buf[1];
	IICreadBytes(dev_addr, reg_addr, 1, buf);
	return buf[0];
}

#define MPU9250_I2C_GYROACC_ADDR  	0x68
#define MPU9250_I2C_MAG_ADDR  		0x0c

int mpu9250_setup_i2c(u8 slave_addr)
{
    PlatformI2CParam i2cParam;
	
	i2cParam.speed = PLATFORM_I2C_SPEED_FAST;
	i2cParam.slaveAddr = slave_addr;	

    //MOD_CHECK_ID( i2c, mpu9250_i2c_id );
    return platform_i2c_setup( mpu9250_i2c_id, &i2cParam);
}

int mpu9250_close_i2c() 
{
	//MOD_CHECK_ID( i2c, mpu9250_i2c_id );
    return platform_i2c_close( mpu9250_i2c_id );
}


// mpu9250 apis
int mpu9250_read_dmp(mpu9250_dmpraw_t *dmp_data)
{
	//int ret;
	IICreadBytes(GYRO_ADDRESS, 0x74, 42, dmp_data->data);
	IICwriteByte(GYRO_ADDRESS, MPU9250_RA_USER_CTRL , 0xcc);//FIFO_RST | DMP_RST | DMP_EN | FIFO_EN 
	return 0;
}

long getdmplong(mpu9250_dmpraw_t *d, unsigned char address)
{
  long dmptempl;
  dmptempl = d->data[address];
  dmptempl <<= 8;
  dmptempl |= d->data[address+1];
  dmptempl <<= 8;
  dmptempl |= d->data[address+2];
  dmptempl <<= 8;
  dmptempl |= d->data[address+3];
  return dmptempl;
}

// 由dmpraw计算四元数
void mpu9250_get_quaternion(mpu9250_dmpraw_t *d, mpu9250_quaternionf_t *q)
{    
	q->a = getdmplong(d, 0)/1073741824.0;  
	q->x = getdmplong(d, 4)/1073741824.0;
	q->y = getdmplong(d, 8)/1073741824.0;
	q->z = getdmplong(d, 12)/1073741824.0;
}

// 由四元数计算计算yaw、pitch、roll
void mpu9250_get_yawpitchroll(mpu9250_quaternionf_t *q, mpu9250_yprf_t *ypr)
{
	ypr->yaw = -latan2(2.0*(q->a*q->z + q->x*q->y),
	                     1 - 2.0*(q->y*q->y + q->z*q->z))*57.3;  	//yaw
	
	ypr->pitch = -lasin(2.0*(q->a*q->y - q->z*q->x))*57.3;			//pitch

	ypr->roll = latan2(2.0*(q->a*q->x + q->y*q->z),
	                       1 - 2.0*(q->x*q->x + q->y*q->y))*57.3; 	//roll
}

//计算加速度
void mpu9250_get_acc(mpu9250_accelf_t *acc)
{
	u8 buf[16];
	IICreadBytes(GYRO_ADDRESS, MPU9250_RA_ACCEL_XOUT_H, 14, buf);
	acc->x =	((s16)((buf[1]<<8)|buf[0]))/16384.0;//acc-x
	acc->y =	((s16)((buf[3]<<8)|buf[2]))/16384.0;//acc-y
	acc->z =	((s16)((buf[5]<<8)|buf[4]))/16384.0;//acc-z
}

//计算角速度
void mpu9250_get_gyro(mpu9250_gyrof_t *gyro)
{
	u8 buf[16];
	IICreadBytes(GYRO_ADDRESS, MPU9250_RA_ACCEL_XOUT_H, 14, buf);
	gyro->x =	((s16)((buf[7]<<8)|buf[6]))/8192.0;//gyro-x
	gyro->y =	((s16)((buf[9]<<8)|buf[8]))/8192.0;//gyro-y
	gyro->z =	((s16)((buf[11]<<8)|buf[10]))/8192.0;//gyro-z
}

//获取 X/Y/Z 磁力计值
void mpu9250_get_mag(mpu9250_magf_t *mag)
{
	u8 buf[10];
	u8 temp;
	
	while(1) {
		temp = IIC_ReadOneByte(MAG_ADDRESS, 0x09) & 0x08;
		if(temp) {		
			IIC_ReadOneByte(MAG_ADDRESS, MPU9250_RA_MAG_XOUT_L);
			return;
		}
		else {
			IICreadBytes(MAG_ADDRESS, MPU9250_RA_MAG_XOUT_L, 6, buf);
			mag->x = ((s16)(buf[1]<<8)|buf[0]) * 0.15;	//mag_x
			mag->y = ((s16)(buf[3]<<8)|buf[2]) * 0.15;	//mag_y
			mag->z = ((s16)(buf[5]<<8)|buf[4]) *0.15;	//mag_z
			break;
		}
	}
}

void loadfirmware(void)
{
	unsigned int datanum = 0;
	unsigned char bank;
	unsigned lastbank = 1;
	for (datanum=0; datanum<1929; datanum++) {
		bank = datanum / 256;
		if (lastbank != bank) {
			IICwriteByte(GYRO_ADDRESS, 0x6d, bank);
			IICwriteByte(GYRO_ADDRESS, 0x6e, 0);
		}
		IICwriteByte(GYRO_ADDRESS, 0x6f, dmpmemorydata[datanum]);  
		lastbank = bank; 
	}
}

void loadcfgupd(void)
{
	unsigned char line;
	unsigned char bank;
	unsigned char datacounts=0;
	unsigned char bytes2write;
	unsigned char offset;
	unsigned char writingcounts;

	for (line=0; line<37; line++) {
		bank = dmpcfgupddata[datacounts++];
		offset = dmpcfgupddata[datacounts++];
		bytes2write = dmpcfgupddata[datacounts];
		
		IICwriteByte(GYRO_ADDRESS, 0x6d, bank);  
		IICwriteByte(GYRO_ADDRESS, 0x6e, offset);
		
		for (writingcounts=0; writingcounts<bytes2write; writingcounts++) {
			IICwriteByte(GYRO_ADDRESS, 0x6f, dmpcfgupddata[++datacounts]);  
		}
		datacounts++;
	}
}

void mpu9250_sleep()
{
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x40);//pw1	
}

void mpu9250_wakeup()
{
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x00);//pw1	
}

void mpu9250_reset_fifo(void)
{	
	u8 tmp = IIC_ReadOneByte(GYRO_ADDRESS, MPU9250_RA_USER_CTRL);
	IICwriteByte(GYRO_ADDRESS, MPU9250_RA_USER_CTRL, tmp | (1<<MPU9250_USERCTRL_FIFO_RESET_BIT));
    //IICwriteBit(GYRO_ADDRESS, MPU9250_RA_USER_CTRL, MPU9250_USERCTRL_FIFO_RESET_BIT, 1);
}

u16 mpu9250_get_fifo_count(void) 
{
	u8 buffer[2] = {0};
	IICreadBytes(GYRO_ADDRESS, MPU9250_RA_FIFO_COUNTH, 2, buffer);
	return (((u16)buffer[0]) << 8) | buffer[1];
}

void mpu9250_init_with_dmp(void)
{ 
	
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x80);//pw1	
	Delayms(100);  
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_PWR_MGMT_1, 0x00);//pw1	
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_PWR_MGMT_2, 0x00);//pw2	
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_SMPLRT_DIV, 0x04);//1000/50 = 20hz
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_CONFIG, 0x06); //1KHZ
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_GYRO_CONFIG, 0x18);//+- 2000
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_ACCEL_CONFIG, 0x10);//+- 4g
	IICwriteByte(GYRO_ADDRESS, MPU9250_RA_INT_PIN_CFG, 0x02);				// i2c bypass mode
	
	Delayms(30);
	loadfirmware(); 
	loadcfgupd();
	
	Delayms(30);
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_DMP_CFG_1 , 0x03);                         
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_DMP_CFG_2 , 0x00);                         
	IICwriteByte(GYRO_ADDRESS,MPU9250_RA_USER_CTRL , 0xcc);  

}


// Lua: mpu9250.init(i2c_id)
static int lua_mpu9250_init(lua_State *L) 
{
	//int ret;
	mpu9250_i2c_id = luaL_checkinteger(L, 1);
	mpu9250_setup_i2c(MPU9250_I2C_GYROACC_ADDR);
	MOD_CHECK_ID( i2c, mpu9250_i2c_id );
	
	mpu9250_init_with_dmp();
	
	mpu9250_close_i2c(); 
	
}

// Lua: yaw, pitch, roll = mpu9250.ypr()
static int lua_mpu9250_ypr(lua_State *L) 
{
	int ret;
	int cnt;
	mpu9250_dmpraw_t dmp_raw;
	mpu9250_quaternionf_t quaternion;
	mpu9250_yprf_t ypr;
	
	mpu9250_setup_i2c(MPU9250_I2C_GYROACC_ADDR);
	MOD_CHECK_ID( i2c, mpu9250_i2c_id );
	
	// todo: err handler
	while(1) {
		cnt = mpu9250_get_fifo_count();
		if (cnt >= 0x200) {
			mpu9250_reset_fifo();
		} else if (cnt >= 0x2a) {
			ret = mpu9250_read_dmp(&dmp_raw);
			mpu9250_reset_fifo();
			mpu9250_get_quaternion(&dmp_raw, &quaternion);
			mpu9250_get_yawpitchroll(&quaternion, &ypr);
			break;
		}
	}
	mpu9250_close_i2c(); 
	
	lua_pushinteger(L, (s32)ypr.yaw);
	lua_pushinteger(L, (s32)ypr.pitch);
	lua_pushinteger(L, (s32)ypr.roll);
	return 3;
}

// Lua: mpu9250.sleep() 
static int lua_mpu9250_sleep(lua_State *L) 
{
	mpu9250_setup_i2c(MPU9250_I2C_GYROACC_ADDR);
	MOD_CHECK_ID( i2c, mpu9250_i2c_id );
	mpu9250_sleep();
	mpu9250_close_i2c();
	return 0;
}

// Lua: mpu9250.wakeup()
static int lua_mpu9250_wakeup(lua_State *L) 
{	
	mpu9250_setup_i2c(MPU9250_I2C_GYROACC_ADDR);
	MOD_CHECK_ID( i2c, mpu9250_i2c_id );
	mpu9250_wakeup();
	mpu9250_close_i2c();
	return 0;
}

// Lua: az = mpu9250.az()
static int lua_mpu9250_az(lua_State *L) 
{
	double az;
	mpu9250_magf_t mag_data;
	
	mpu9250_setup_i2c(MPU9250_I2C_MAG_ADDR);
	MOD_CHECK_ID( i2c, mpu9250_i2c_id );
	
	mpu9250_get_mag(&mag_data);
	
	// 仅用xy做个最最最简单的计算。。
	// az取值范围0~359整数
	az = ((latan2(mag_data.y, mag_data.x) *57.3) +180);
	if (az > 359)
		az = 359;

	mpu9250_close_i2c(); 
	lua_pushinteger(L, (s32)az);
	return 1;
}

// ============== PASS ===============
// PASS Lua: a, x, y, z = mpu9250.q()
static int lua_mpu9250_q(lua_State *L) 
{
	/*
	int ret;
	mpu9250_dmpraw_t dmp_raw;
	mpu9250_quaternionf_t quaternion;
	mpu9250_setup_i2c(MPU9250_I2C_GYROACC_ADDR);
	
	// todo: err handler
	ret = mpu9250_read_dmp(&dmp_raw);
	ret = mpu9250_get_quaternion_int(&dmp_raw, &quaternion);
	
	mpu9250_close_i2c(); 
	
	lua_pushinteger(L, (s32)quaternion.a);
	lua_pushinteger(L, (s32)quaternion.x);
	lua_pushinteger(L, (s32)quaternion.y);
	lua_pushinteger(L, (s32)quaternion.z);
	return 4;
	*/
	return 0;	//pass
}

// PASS Lua: x, y, z = mpu9250.mag()
static int lua_mpu9250_mag(lua_State *L) 
{
	return 0;	//pass
}

// PASS Lua: x, y, z = mpu9250.acc()
static int lua_mpu9250_acc(lua_State *L) 
{
	return 0;	//pass
}

// PASS Lua: x, y, z = mpu9250.gyro()
static int lua_mpu9250_gyro(lua_State *L) 
{
	return 0;	//pass
}




// Module function map
#include "lrodefs.h"
const LUA_REG_TYPE mpu9250_map[] = 
{
  { LSTRKEY( "init" ),  		LFUNCVAL( lua_mpu9250_init ) },
  { LSTRKEY( "ypr" ),  			LFUNCVAL( lua_mpu9250_ypr ) },
  //{ LSTRKEY( "q" ), 			LFUNCVAL( lua_mpu9250_q ) },
  //{ LSTRKEY( "mag" ), 			LFUNCVAL( lua_mpu9250_mag ) },
  //{ LSTRKEY( "acc" ), 			LFUNCVAL( lua_mpu9250_acc ) },
  //{ LSTRKEY( "gyro" ), 			LFUNCVAL( lua_mpu9250_gyro ) },
  { LSTRKEY( "sleep" ), 		LFUNCVAL( lua_mpu9250_sleep ) },
  { LSTRKEY( "wakeup" ), 		LFUNCVAL( lua_mpu9250_wakeup ) },
  { LSTRKEY( "az" ), 			LFUNCVAL( lua_mpu9250_az ) },	
  
  { LNILKEY, LNILVAL }
};

LUALIB_API int luaopen_mpu9250( lua_State *L )
{
  luaL_register( L, AUXLIB_MPU9250, mpu9250_map );
  
  return 1;
}





